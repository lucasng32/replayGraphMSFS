<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Visualization</title>
    <!-- Load Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        body {
            background-color: transparent; /* Fully transparent background */
        }
        .container {
            margin-top: 20px;
        }
        .graph-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin-bottom: 10px;
        }
        .toolbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100%;
            background: #f8f9fa;
            border-right: 1px solid #ddd;
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        .toolbar.hidden {
            transform: translateX(-100%);
        }
        .toolbar-content {
            padding: 20px;
        }
        .settings-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
        }
        .play-pause-button {
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 1001;
        }
        .slider-container {
            position: fixed;
            bottom: 0;
            width: 100%;
            background: #f8f9fa;
            padding: 10px;
            border-top: 1px solid #ddd;
            z-index: 1001;
        }
        #timeSlider {
            width: calc(100% - 40px);
        }
    </style>
</head>
<body>
    <button class="btn btn-primary settings-button" id="settingsButton">Settings</button>
    <button class="btn btn-secondary play-pause-button" id="playPauseButton">Pause</button>
    <div class="toolbar hidden" id="toolbar">
        <div class="toolbar-content">
            <button class="btn btn-info btn-block graph-select" id="altitudeButton">Altitude</button>
            <button class="btn btn-info btn-block graph-select" id="gForceButton">G-Force</button>
            <button class="btn btn-info btn-block graph-select" id="velocityWorldYButton">Rate of Climb</button>
        </div>
    </div>
    <div class="container">
        <div id="graphsContainer" class="row">
            <!-- Graph containers will be dynamically added here -->
        </div>
    </div>
    <div class="slider-container">
        <input type="range" id="timeSlider" min="0" max="100" step="1" value="0">
    </div>

    <script>
        const graphs = {
            altitude: { x: [], y: [], id: 'altitudeGraph' },
            gForce: { x: [], y: [], id: 'gForceGraph' },
            velocityWorldY: { x: [], y: [], id: 'rateOfClimbGraph' }
        };

        const activeGraphs = new Set();
        let shouldReRender = true;
        let isPlaying = true;
        let totalDuration = 100;

        function renderGraphs() {
            const container = document.getElementById('graphsContainer');
            container.innerHTML = ''; // Clear existing graphs

            activeGraphs.forEach(type => {
                const div = document.createElement('div');
                div.className = 'col-md-6 graph-container';
                div.id = type + 'Container';

                const graphDiv = document.createElement('div');
                graphDiv.id = graphs[type].id;
                div.appendChild(graphDiv);
                container.appendChild(div);

                const layout = {
                    title: `${type.charAt(0).toUpperCase() + type.slice(1)} Data`,
                    xaxis: { title: 'Time (s)' },
                    yaxis: { title: type.charAt(0).toUpperCase() + type.slice(1) }
                };

                Plotly.newPlot(graphs[type].id, [{
                    x: graphs[type].x,
                    y: graphs[type].y,
                    mode: 'lines',
                    line: { color: 'blue' }
                }], layout, { responsive: true });
            });

            if (activeGraphs.size === 0) {
                document.querySelector('.slider-container').style.display = 'none';
            } else {
                document.querySelector('.slider-container').style.display = 'block';
            }
        }

        function handlePlayPause() {
            isPlaying = !isPlaying;
            document.getElementById('playPauseButton').textContent = isPlaying ? 'Pause' : 'Play';
            const command = isPlaying ? 'play' : 'pause';
            socket.send(JSON.stringify({ command }));
        }

        function handleSliderInput() {
            const sliderValue = parseFloat(document.getElementById('timeSlider').value);
            const newTimestamp = sliderValue / 100 * totalDuration;
            socket.send(JSON.stringify({ command: 'seek', timestamp: newTimestamp }));
        }

        document.getElementById('settingsButton').addEventListener('click', function () {
            const toolbar = document.getElementById('toolbar');
            toolbar.classList.toggle('hidden');
        });

        document.getElementById('playPauseButton').addEventListener('click', handlePlayPause);

        document.querySelectorAll('.graph-select').forEach(button => {
            button.addEventListener('click', function () {
                const type = this.id.replace('Button', '');
                if (activeGraphs.has(type)) {
                    activeGraphs.delete(type);
                    document.getElementById(type + 'Container').remove();
                } else {
                    activeGraphs.add(type);
                    renderGraphs();
                }
                shouldReRender = true;
            });
        });

        document.getElementById('timeSlider').addEventListener('input', handleSliderInput);

        const socket = new WebSocket('ws://localhost:1234');

        socket.onopen = function () {
            console.log('WebSocket connection established');
        };

        socket.onmessage = function (event) {
            const parsedData = JSON.parse(event.data);
            const allData = parsedData.data;
            const currentTimestamp = parsedData.timestamp;
            const dataMode = parsedData.dataMode;
            const toReload = parsedData.toReload;

            if (dataMode) {
                allData.forEach(item => {
                    const timestamp = item.timestamp / 1000;
                    Object.keys(graphs).forEach(key => {
                        graphs[key].x.push(timestamp);
                        graphs[key].y.push(item[key]);
                    })
                });
            } else {
                try {
                    const currentTime = currentTimestamp / 1000;
                    if (currentTime) {
                        document.querySelectorAll('.graph-container').forEach(container => {
                            Plotly.relayout(container.querySelector('div').id, {
                                shapes: [{
                                    type: 'line',
                                    x0: currentTime,
                                    y0: 0,
                                    x1: currentTime,
                                    y1: 1,
                                    xref: 'x',
                                    yref: 'paper',
                                    line: {
                                        color: 'red',
                                        width: 2,
                                        dash: 'dashdot'
                                    }
                                }]
                            });
                        });
                    }
                    Object.keys(graphs).forEach(key => {
                        graphs[key].x = allData.map(item => item.timestamp / 1000)
                        graphs[key].y = allData.map(item => item[key]);
                    });
                    const slider = document.getElementById('timeSlider');
                    totalDuration = allData[allData.length - 1].timestamp / 1000;
                    slider.value = (currentTime / totalDuration) * 100;
                } catch (e) {
                    console.error('Error updating graphs during replay:', e);
                }
            }

            if (shouldReRender || toReload) {
                renderGraphs();
                shouldReRender = false;
            }
        };

        socket.onclose = function () {
            console.log('WebSocket connection closed');
        };

        socket.onerror = function (error) {
            console.error('WebSocket error:', error);
        };
    </script>
</body>
</html>
