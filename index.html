<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Visualization</title>
    <!-- Load Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        body {
            background-color: transparent; /* Fully transparent background */
        }
        .container {
            margin-top: 20px;
        }
        .graph-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin-bottom: 10px;
        }
        .toolbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100%;
            background: #f8f9fa;
            border-right: 1px solid #ddd;
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        .toolbar.hidden {
            transform: translateX(-100%);
        }
        .toolbar-content {
            padding: 20px;
        }
        .settings-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
        }
        .play-pause-button {
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 1001;
        }
        .slider-container {
            position: fixed;
            bottom: 0;
            width: 100%;
            background: #f8f9fa;
            padding: 10px;
            border-top: 1px solid #ddd;
            z-index: 1001;
        }
        #timeSlider {
            width: calc(100% - 40px);
        }
    </style>
</head>
<body>
    <button class="btn btn-primary settings-button" id="settingsButton">Settings</button>
    <button class="btn btn-secondary play-pause-button" id="playPauseButton">Pause</button>
    <div class="toolbar hidden" id="toolbar">
        <div class="toolbar-content">
            <button class="btn btn-info btn-block graph-select" id="altitudeButton">Altitude</button>
            <button class="btn btn-info btn-block graph-select" id="gForceButton">G-Force</button>
            <button class="btn btn-info btn-block graph-select" id="velocityWorldYButton">Rate of Climb</button>
            <button class="btn btn-info btn-block graph-select" id="incidenceAlphaButton">Angle of Attack</button>
            <button class="btn btn-info btn-block graph-select" id="pitchButton">Pitch Angle</button>
            <button class="btn btn-info btn-block graph-select" id="indicatedAirspeedButton">IAS</button>
            <button class="btn btn-info btn-block graph-select" id="windSpeedButton">Wind Speed</button>
            <button class="btn btn-info btn-block graph-select" id="aileronPositionButton">Aileron Position</button>
        </div>
    </div>
    <div class="container">
        <div id="graphsContainer" class="row">
            <!-- Graph containers will be dynamically added here -->
        </div>
    </div>
    <div class="slider-container">
        <input type="range" id="timeSlider" min="0" max="100" step="1" value="0">
    </div>

    <script>
        const graphs = {
            altitude: { x: [], y: [], id: 'altitudeGraph', limits: []},
            gForce: { x: [], y: [], id: 'gForceGraph', limits: {}},
            velocityWorldY: { x: [], y: [], id: 'rateOfClimbGraph' , limits: []},
            incidenceAlpha: { x: [], y: [], id: 'angleOfAttackGraph', limits: {'stallAlpha': 0}},
            pitch: { x: [], y: [], id: 'pitchGraph', limits: {'staticPitch': 0}},
            indicatedAirspeed: { x: [], y: [], id: 'indicatedAirspeedGraph', limits: {'flapsUpStallSpeed': 0}},
            windSpeed: { x: [], y: [], id: 'windSpeedGraph', limits: {}},
            aileronPosition: { x: [], y: [], id: 'aileronPositionGraph', limits: {}}
        };

        const activeGraphs = new Set();
        let shouldReRender = true;
        let isPlaying = true;
        let totalDuration = 100;

        function renderGraphs() {
            const container = document.getElementById('graphsContainer');
            container.innerHTML = ''; // Clear existing graphs

            activeGraphs.forEach(type => {
                const div = document.createElement('div');
                div.className = 'col-md-6 graph-container';
                div.id = type + 'Container';

                const graphDiv = document.createElement('div');
                graphDiv.id = graphs[type].id;
                div.appendChild(graphDiv);
                container.appendChild(div);

                // Base layout
                const layout = {
                    title: `${type.charAt(0).toUpperCase() + type.slice(1)} Data`,
                    xaxis: { title: 'Time (s)' },
                    yaxis: { title: type.charAt(0).toUpperCase() + type.slice(1) },
                    annotations: [] // For horizontal lines and labels
                };

                // Base data for the graph
                const data = [{
                    x: graphs[type].x,
                    y: graphs[type].y,
                    mode: 'lines',
                    line: { color: 'blue' }
                }];

                // Add horizontal lines for limits
                const limits = graphs[type].limits;
                Object.keys(limits).forEach(limitName => {
                    const limitValue = limits[limitName];
                    data.push({
                        x: [Math.min(...graphs[type].x), Math.max(...graphs[type].x)],
                        y: [limitValue, limitValue],
                        mode: 'lines',
                        line: { color: 'red', dash: 'dashdot' },
                        name: limitName
                    });

                    layout.annotations.push({
                        x: Math.max(...graphs[type].x),
                        y: limitValue,
                        text: limitName,
                        showarrow: true,
                        arrowhead: 2,
                        ax: 0,
                        ay: -40
                    });
                });

                Plotly.newPlot(graphs[type].id, data, layout, { responsive: true });
            });

            if (activeGraphs.size === 0) {
                document.querySelector('.slider-container').style.display = 'none';
            } else {
                document.querySelector('.slider-container').style.display = 'block';
            }
        }


        function handlePlayPause() {
            isPlaying = !isPlaying;
            document.getElementById('playPauseButton').textContent = isPlaying ? 'Pause' : 'Play';
            const command = isPlaying ? 'play' : 'pause';
            socket.send(JSON.stringify({ command }));
        }

        function handleSliderInput() {
            const sliderValue = parseFloat(document.getElementById('timeSlider').value);
            const newTimestamp = sliderValue / 100 * totalDuration;
            socket.send(JSON.stringify({ command: 'seek', timestamp: newTimestamp }));
        }

        document.getElementById('settingsButton').addEventListener('click', function () {
            const toolbar = document.getElementById('toolbar');
            toolbar.classList.toggle('hidden');
        });

        document.getElementById('playPauseButton').addEventListener('click', handlePlayPause);

        document.querySelectorAll('.graph-select').forEach(button => {
            button.addEventListener('click', function () {
                const type = this.id.replace('Button', '');
                if (activeGraphs.has(type)) {
                    activeGraphs.delete(type);
                    document.getElementById(type + 'Container').remove();
                } else {
                    activeGraphs.add(type);
                    renderGraphs();
                }
                shouldReRender = true;
            });
        });

        document.getElementById('timeSlider').addEventListener('input', handleSliderInput);

        const socket = new WebSocket('ws://localhost:1234');

        socket.onopen = function () {
            console.log('WebSocket connection established');
        };

        socket.onmessage = function (event) {
            const parsedData = JSON.parse(event.data);
            const allData = parsedData.data;
            const aircraftModel = parsedData.aircraftModel;
            const currentTimestamp = parsedData.timestamp;
            const dataMode = parsedData.dataMode;
            const toReload = parsedData.toReload;

            if (dataMode) {
                allData.forEach(item => {
                    const timestamp = item.timestamp / 1000;
                    Object.keys(graphs).forEach(key => {
                        graphs[key].x.push(timestamp);
                        graphs[key].y.push(item[key]);
                    })
                });
            } else {
                try {
                    const currentTime = currentTimestamp / 1000;
                    if (currentTime > 0.1) {
                        document.querySelectorAll('.graph-container').forEach(container => {
                            Plotly.relayout(container.querySelector('div').id, {
                                shapes: [{
                                    type: 'line',
                                    x0: currentTime,
                                    y0: 0,
                                    x1: currentTime,
                                    y1: 1,
                                    xref: 'x',
                                    yref: 'paper',
                                    line: {
                                        color: 'red',
                                        width: 2,
                                        dash: 'dashdot'
                                    }
                                }]
                            });
                        });
                        const slider = document.getElementById('timeSlider');
                        slider.value = (currentTime / totalDuration) * 100;
                    }
                } catch (e) {
                    console.error('Error updating graphs during replay:', e);
                }
            }

            if (shouldReRender || toReload) {
                Object.keys(graphs).forEach(key => {
                    const graph = graphs[key];
                    const limits = graph.limits;

                    Object.keys(limits).forEach(limitName => {
                        // Check if the aircraftModel contains the limit property
                        if (aircraftModel.hasOwnProperty(limitName)) {
                            limits[limitName] = aircraftModel[limitName];
                        }
                    });
                });

                Object.keys(graphs).forEach(key => {
                    graphs[key].x = allData.map(item => item.timestamp / 1000)
                    graphs[key].y = allData.map(item => item[key]);
                });
                totalDuration = allData[allData.length - 1].timestamp / 1000;
                renderGraphs();
                shouldReRender = false;
            }
        };

        socket.onclose = function () {
            console.log('WebSocket connection closed');
        };

        socket.onerror = function (error) {
            console.error('WebSocket error:', error);
        };
    </script>
</body>
</html>
